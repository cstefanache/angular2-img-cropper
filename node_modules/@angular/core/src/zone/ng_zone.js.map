{"version":3,"file":"ng_zone.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/zone/ng_zone.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '../facade/async';\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * ### Example\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo'.\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *       // reenter the Angular zone and display done\n *       this._ngZone.run(() => {console.log('Outside Done!') });\n *     }}));\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n * @experimental\n */\nexport class NgZone {\n  private outer: Zone;\n  private inner: Zone;\n\n  private _hasPendingMicrotasks: boolean = false;\n  private _hasPendingMacrotasks: boolean = false;\n\n  private _isStable = true;\n  private _nesting: number = 0;\n  private _onUnstable: EventEmitter<any> = new EventEmitter(false);\n  private _onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n  private _onStable: EventEmitter<any> = new EventEmitter(false);\n  private _onErrorEvents: EventEmitter<any> = new EventEmitter(false);\n\n  constructor({enableLongStackTrace = false}) {\n    if (typeof Zone == 'undefined') {\n      throw new Error('Angular requires Zone.js prolyfill.');\n    }\n\n    Zone.assertZonePatched();\n\n    this.outer = this.inner = Zone.current;\n\n    if ((Zone as any)['wtfZoneSpec']) {\n      this.inner = this.inner.fork((Zone as any)['wtfZoneSpec']);\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      this.inner = this.inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n\n    this.forkInnerZoneWithAngularBehavior();\n  }\n\n  static isInAngularZone(): boolean { return Zone.current.get('isAngularZone') === true; }\n\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new Error('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new Error('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run(fn: () => any): any { return this.inner.run(fn); }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded(fn: () => any): any { return this.inner.runGuarded(fn); }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular(fn: () => any): any { return this.outer.run(fn); }\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  get onUnstable(): EventEmitter<any> { return this._onUnstable; }\n\n  /**\n   * Notifies when there is no more microtasks enqueue in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  get onMicrotaskEmpty(): EventEmitter<any> { return this._onMicrotaskEmpty; }\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  get onStable(): EventEmitter<any> { return this._onStable; }\n\n  /**\n   * Notify that an error has been delivered.\n   */\n  get onError(): EventEmitter<any> { return this._onErrorEvents; }\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  get isStable(): boolean { return this._isStable; }\n\n  get hasPendingMicrotasks(): boolean { return this._hasPendingMicrotasks; }\n\n  get hasPendingMacrotasks(): boolean { return this._hasPendingMacrotasks; }\n\n  private checkStable() {\n    if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {\n      try {\n        this._nesting++;\n        this._onMicrotaskEmpty.emit(null);\n      } finally {\n        this._nesting--;\n        if (!this._hasPendingMicrotasks) {\n          try {\n            this.runOutsideAngular(() => this._onStable.emit(null));\n          } finally {\n            this._isStable = true;\n          }\n        }\n      }\n    }\n  }\n\n  private forkInnerZoneWithAngularBehavior() {\n    this.inner = this.inner.fork({\n      name: 'angular',\n      properties: <any>{'isAngularZone': true},\n      onInvokeTask: (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task,\n                     applyThis: any, applyArgs: any): any => {\n        try {\n          this.onEnter();\n          return delegate.invokeTask(target, task, applyThis, applyArgs);\n        } finally {\n          this.onLeave();\n        }\n      },\n\n\n      onInvoke: (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function,\n                 applyThis: any, applyArgs: any[], source: string): any => {\n        try {\n          this.onEnter();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          this.onLeave();\n        }\n      },\n\n      onHasTask:\n          (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => {\n            delegate.hasTask(target, hasTaskState);\n            if (current === target) {\n              // We are only interested in hasTask events which originate from our zone\n              // (A child hasTask event is not interesting to us)\n              if (hasTaskState.change == 'microTask') {\n                this.setHasMicrotask(hasTaskState.microTask);\n              } else if (hasTaskState.change == 'macroTask') {\n                this.setHasMacrotask(hasTaskState.macroTask);\n              }\n            }\n          },\n\n      onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n        delegate.handleError(target, error);\n        this.triggerError(error);\n        return false;\n      }\n    });\n  }\n\n  private onEnter() {\n    this._nesting++;\n    if (this._isStable) {\n      this._isStable = false;\n      this._onUnstable.emit(null);\n    }\n  }\n\n  private onLeave() {\n    this._nesting--;\n    this.checkStable();\n  }\n\n  private setHasMicrotask(hasMicrotasks: boolean) {\n    this._hasPendingMicrotasks = hasMicrotasks;\n    this.checkStable();\n  }\n\n  private setHasMacrotask(hasMacrotasks: boolean) { this._hasPendingMacrotasks = hasMacrotasks; }\n\n  private triggerError(error: any) { this._onErrorEvents.emit(error); }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}