{"version":3,"file":"api.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/render/api.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAMI,EAAC,aAAa,EAAC,MAAM,kBAAkB;AAG9C;;GAEG;AACH,uDAAuD;AACvD;IACE,6BACW,EAAU,EAAS,WAAmB,EAAS,SAAiB,EAChE,aAAgC,EAAS,MAA2B,EACpE,UAAqC;QAFrC,OAAE,GAAF,EAAE,CAAQ;QAAS,gBAAW,GAAX,WAAW,CAAQ;QAAS,cAAS,GAAT,SAAS,CAAQ;QAChE,kBAAa,GAAb,aAAa,CAAmB;QAAS,WAAM,GAAN,MAAM,CAAqB;QACpE,eAAU,GAAV,UAAU,CAA2B;IAAG,CAAC;IACtD,0BAAC;AAAD,CAAC,AALD,IAKC;AAED;IAAA;IAOA,CAAC;IANC,sBAAI,qCAAQ;aAAZ,cAA2B,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;;;OAAA;IACpD,sBAAI,sCAAS;aAAb,cAAuB,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;;;OAAA;IAChD,sBAAI,2CAAc;aAAlB,cAA8B,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;;;OAAA;IACvD,sBAAI,uCAAU;aAAd,cAAyC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;;;OAAA;IAClE,sBAAI,oCAAO;aAAX,cAAqB,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;;;OAAA;IAC9C,sBAAI,mCAAM;aAAV,cAAuB,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;;;OAAA;IAClD,sBAAC;AAAD,CAAC,AAPD,IAOC;AAED;;GAEG;AACH;IAAA;IA6CA,CAAC;IAAD,eAAC;AAAD,CAAC,AA7CD,IA6CC;AAED;;;;;;;;;;;;GAYG;AACH;IAAA;IAEA,CAAC;IAAD,mBAAC;AAAD,CAAC,AAFD,IAEC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationKeyframe} from '../../src/animation/animation_keyframe';\nimport {AnimationPlayer} from '../../src/animation/animation_player';\nimport {AnimationStyles} from '../../src/animation/animation_styles';\nimport {Injector} from '../di/injector';\nimport {unimplemented} from '../facade/errors';\nimport {ViewEncapsulation} from '../metadata/view';\n\n/**\n * @experimental\n */\n// TODO (matsko): add typing for the animation function\nexport class RenderComponentType {\n  constructor(\n      public id: string, public templateUrl: string, public slotCount: number,\n      public encapsulation: ViewEncapsulation, public styles: Array<string|any[]>,\n      public animations: {[key: string]: Function}) {}\n}\n\nexport abstract class RenderDebugInfo {\n  get injector(): Injector { return unimplemented(); }\n  get component(): any { return unimplemented(); }\n  get providerTokens(): any[] { return unimplemented(); }\n  get references(): {[key: string]: any} { return unimplemented(); }\n  get context(): any { return unimplemented(); }\n  get source(): string { return unimplemented(); }\n}\n\n/**\n * @experimental\n */\nexport abstract class Renderer {\n  abstract selectRootElement(selectorOrNode: string|any, debugInfo?: RenderDebugInfo): any;\n\n  abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;\n\n  abstract createViewRoot(hostElement: any): any;\n\n  abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;\n\n  abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;\n\n  abstract projectNodes(parentElement: any, nodes: any[]): void;\n\n  abstract attachViewAfter(node: any, viewRootNodes: any[]): void;\n\n  abstract detachView(viewRootNodes: any[]): void;\n\n  abstract destroyView(hostElement: any, viewAllNodes: any[]): void;\n\n  abstract listen(renderElement: any, name: string, callback: Function): Function;\n\n  abstract listenGlobal(target: string, name: string, callback: Function): Function;\n\n  abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;\n\n  abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string):\n      void;\n\n  /**\n   * Used only in debug mode to serialize property changes to dom nodes as attributes.\n   */\n  abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string):\n      void;\n\n  abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;\n\n  abstract setElementStyle(renderElement: any, styleName: string, styleValue: string): void;\n\n  abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;\n\n  abstract setText(renderNode: any, text: string): void;\n\n  abstract animate(\n      element: any, startingStyles: AnimationStyles, keyframes: AnimationKeyframe[],\n      duration: number, delay: number, easing: string): AnimationPlayer;\n}\n\n/**\n * Injectable service that provides a low-level interface for modifying the UI.\n *\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\n * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}\n * respectively.\n *\n * If you are implementing a custom renderer, you must implement this interface.\n *\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\n * @experimental\n */\nexport abstract class RootRenderer {\n  abstract renderComponent(componentType: RenderComponentType): Renderer;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}