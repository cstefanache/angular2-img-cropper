{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../../../modules/@angular/compiler/src/expression_parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\n\nimport * as chars from '../chars';\nimport {escapeRegExp, isBlank, isPresent} from '../facade/lang';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\n\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n  return new RegExp(pattern, 'g');\n}\n\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new _ParseAST(\n                    input, location, tokens, sourceToLex.length, true, this.errors,\n                    input.length - sourceToLex.length)\n                    .parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    var ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    var ast = this._parseBindingAst(input, location, interpolationConfig);\n    if (!SimpleExpressionChecker.check(ast)) {\n      this._reportError(\n          'Host binding expression can only contain field access and constants', input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    var quote = this._parseQuote(input, location);\n\n    if (isPresent(quote)) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n               input, location, tokens, sourceToLex.length, false, this.errors,\n               input.length - sourceToLex.length)\n        .parseChain();\n  }\n\n  private _parseQuote(input: string, location: any): AST {\n    if (isBlank(input)) return null;\n    var prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    var prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(input: string, location: any): TemplateBindingParseResult {\n    var tokens = this._lexer.tokenize(input);\n    return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n        .parseTemplateBindings();\n  }\n\n  parseInterpolation(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    let split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split == null) return null;\n\n    let expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n      const ast = new _ParseAST(\n                      input, location, tokens, sourceToLex.length, false, this.errors,\n                      split.offsets[i] + (expressionText.length - sourceToLex.length))\n                      .parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n        new Interpolation(\n            new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions),\n        input, location, this.errors);\n  }\n\n  splitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      var part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n            'Blank expressions are not allowed in interpolated strings', input,\n            `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n            location);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string, location: any): ASTWithSource {\n    return new ASTWithSource(\n        new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input,\n        location, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return isPresent(i) ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number {\n    var outerQuote: number = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && isBlank(outerQuote)) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (isBlank(outerQuote) && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(\n      input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    var regexp = _createInterpolateRegExp(interpolationConfig);\n    var parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n          `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n          location);\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n      parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n    var errLocation = '';\n    for (var j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ?\n          parts[j] :\n          `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: ({type: any, decorators?: DecoratorInvocation[]}|null)[] = [\n{type: Lexer, },\n];\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: any, public tokens: Token[],\n      public inputLength: number, public parseAction: boolean, private errors: ParserError[],\n      private offset: number) {}\n\n  peek(offset: number): Token {\n    var i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token { return this.peek(0); }\n\n  get inputIndex(): number {\n    return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                                               this.inputLength + this.offset;\n  }\n\n  span(start: number) { return new ParseSpan(start, this.inputIndex); }\n\n  advance() { this.index++; }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    var n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    var n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return '';\n    }\n    this.advance();\n    return n.toString();\n  }\n\n  parseChain(): AST {\n    var exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      var expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) return new EmptyExpr(this.span(start));\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    var result = this.parseExpression();\n    if (this.optionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        var name = this.expectIdentifierOrKeyword();\n        var args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start - this.offset), result, name, args);\n      } while (this.optionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST { return this.parseConditional(); }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        var end = this.inputIndex;\n        var expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator('&&')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      let operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      let operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          return this.parsePrefix();\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n              result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n\n      } else if (this.optionalOperator('?.')) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator('=')) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    let result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    let keys: string[] = [];\n    let values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        var key = this.expectIdentifierOrKeywordOrString();\n        keys.push(key);\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      let span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                      new MethodCall(span, receiver, id, args);\n\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator('=')) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator('=')) {\n          if (!this.parseAction) {\n            this.error('Bindings cannot contain assignments');\n            return new EmptyExpr(this.span(start));\n          }\n\n          let value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    var positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` inbetween.\n   */\n  expectTemplateBindingKey(): string {\n    let result = '';\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  parseTemplateBindings(): TemplateBindingParseResult {\n    let bindings: TemplateBinding[] = [];\n    let prefix: string = null;\n    let warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      var key = this.expectTemplateBindingKey();\n      if (!keyIsVar) {\n        if (prefix == null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      var name: string = null;\n      var expression: ASTWithSource = null;\n      if (keyIsVar) {\n        if (this.optionalOperator('=')) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = '\\$implicit';\n        }\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const start = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(start, this.inputIndex);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(key, keyIsVar, name, expression));\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number = null) {\n    if (isBlank(index)) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n      if (this.next.isError()) {\n        this.errors.push(\n            new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): boolean {\n    var s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.simple;\n  }\n\n  simple = true;\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) { this.simple = false; }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) { this.simple = false; }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) { this.simple = false; }\n\n  visitMethodCall(ast: MethodCall, context: any) { this.simple = false; }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) { this.simple = false; }\n\n  visitFunctionCall(ast: FunctionCall, context: any) { this.simple = false; }\n\n  visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n\n  visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n\n  visitBinary(ast: Binary, context: any) { this.simple = false; }\n\n  visitPrefixNot(ast: PrefixNot, context: any) { this.simple = false; }\n\n  visitConditional(ast: Conditional, context: any) { this.simple = false; }\n\n  visitPipe(ast: BindingPipe, context: any) { this.simple = false; }\n\n  visitKeyedRead(ast: KeyedRead, context: any) { this.simple = false; }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) { this.simple = false; }\n\n  visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n\n  visitChain(ast: Chain, context: any) { this.simple = false; }\n\n  visitQuote(ast: Quote, context: any) { this.simple = false; }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}