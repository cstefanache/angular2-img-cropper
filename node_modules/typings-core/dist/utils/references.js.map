{"version":3,"file":"references.js","sourceRoot":"","sources":["../../src/utils/references.ts"],"names":[],"mappings":";AAAA,qBAA6C,MAC7C,CAAC,CADkD;AACnD,IAAO,UAAU,WAAW,aAAa,CAAC,CAAA;AAC1C,qBAAsC,QAMtC,CAAC,CAN6C;AAMjC,wBAAgB,GAAG,0EAA0E,CAAA;AAY1G,2BAAmC,QAAgB,EAAE,GAAW;IAC9D,IAAM,IAAI,GAAgB,EAAE,CAAA;IAC5B,IAAI,CAAkB,CAAA;IAEtB,GAAG,CAAC;QACF,CAAC,GAAG,wBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAEnC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;YACd,KAAK,CAAA;QACP,CAAC;QAED,IAAI,CAAC,IAAI,CAAC;YACR,KAAK,EAAE,CAAC,CAAC,KAAK;YACd,GAAG,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM;YAC1B,IAAI,EAAE,cAAO,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SACzB,CAAC,CAAA;IACJ,CAAC,QAAQ,CAAC,EAAC;IAEX,MAAM,CAAC,IAAI,CAAA;AACb,CAAC;AAnBe,yBAAiB,oBAmBhC,CAAA;AAED,yBAAiC,QAAgB,EAAE,GAAW;IAC5D,MAAM,CAAC,iBAAiB,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,cAAO,CAAC,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,EAAtB,CAAsB,CAAC,CAAA;AAC5E,CAAC;AAFe,uBAAe,kBAE9B,CAAA;AAED,6BAAqC,KAAe,EAAE,GAAW;IAC/D,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,WAAW,CAAC,IAAI,EAAE,GAAG,CAAC,EAAtB,CAAsB,CAAC,CAAC,IAAI,CAAC,UAAG,CAAC,GAAG,UAAG,CAAA;AAClE,CAAC;AAFe,2BAAmB,sBAElC,CAAA;AAED,qBAA6B,IAAY,EAAE,GAAW;IACpD,MAAM,CAAC,2BAAwB,uBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,eAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,gBAAS,CAAC,IAAI,CAAC,CAAC,UAAM,CAAA;AACjH,CAAC;AAFe,mBAAW,cAE1B,CAAA","sourcesContent":["import { resolve, relative, normalize } from 'path'\nimport isAbsolute = require('is-absolute')\nimport { normalizeSlashes, EOL } from './path'\n\n/**\n * Match reference tags in a file. Matching the newline before the\n * reference to remove unwanted data when removing the line from the file.\n */\nexport const REFERENCE_REGEXP = /^\\/\\/\\/[ \\t]*<reference[ \\t]+path[ \\t]*=(\"|')(.*?)\\1.*?\\/>[ \\t]*\\r?\\n?/gm\n\n/**\n * References come back in a semi-useful structure to enable slicing them\n * from the source code that was passed in.\n */\nexport interface Reference {\n  start: number\n  end: number\n  path: string\n}\n\nexport function extractReferences (contents: string, cwd: string): Reference[] {\n  const refs: Reference[] = []\n  let m: RegExpExecArray\n\n  do {\n    m = REFERENCE_REGEXP.exec(contents)\n\n    if (m == null) {\n      break\n    }\n\n    refs.push({\n      start: m.index,\n      end: m.index + m[0].length,\n      path: resolve(cwd, m[2])\n    })\n  } while (m)\n\n  return refs\n}\n\nexport function parseReferences (contents: string, cwd: string): string[] {\n  return extractReferences(contents, cwd).map(ref => resolve(cwd, ref.path))\n}\n\nexport function stringifyReferences (paths: string[], cwd: string): string {\n  return paths.map(path => toReference(path, cwd)).join(EOL) + EOL\n}\n\nexport function toReference (path: string, cwd: string): string {\n  return `/// <reference path=\"${normalizeSlashes(isAbsolute(path) ? relative(cwd, path) : normalize(path))}\" />`\n}\n"]}