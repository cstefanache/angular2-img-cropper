{"version":3,"file":"compile.js","sourceRoot":"","sources":["../../src/lib/compile.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript'\nimport extend = require('xtend')\nimport has = require('has')\nimport Promise = require('any-promise')\nimport { join, relative, basename } from 'path'\nimport { DependencyTree, Overrides, Emitter } from '../interfaces'\nimport { readFileFrom } from '../utils/fs'\nimport { EOL, normalizeEOL } from '../utils/path'\nimport {\n  resolveFrom,\n  relativeTo,\n  isHttp,\n  isModuleName,\n  normalizeSlashes,\n  pathFromDefinition,\n  normalizeToDefinition,\n  toDefinition\n} from '../utils/path'\nimport { REFERENCE_REGEXP } from '../utils/references'\nimport { PROJECT_NAME, DEPENDENCY_SEPARATOR } from '../utils/config'\nimport TypingsError from './error'\n\n/**\n * Options interface. Supply a name and the current working directory.\n */\nexport interface Options {\n  cwd: string\n  name: string\n  global: boolean\n  meta: boolean\n  emitter: Emitter\n}\n\n/**\n * Result of compiling multiple resolutions.\n */\nexport interface ResolutionResult {\n  main?: string\n  browser?: string\n  [name: string]: string\n}\n\n/**\n * The compiled output data.\n */\nexport interface CompileResult {\n  cwd: string\n  name: string\n  tree: DependencyTree\n  results: ResolutionResult\n  global: boolean\n}\n\n/**\n * Compile a dependency tree using a root name.\n */\nexport function compile (\n  tree: DependencyTree,\n  resolutions: string[],\n  options: Options\n): Promise<CompileResult> {\n  const { name, cwd, global } = options\n  const readFiles: ts.MapLike<Promise<string>> = {}\n\n  // Ensure the global installation is valid.\n  if (tree.global && !global) {\n    return Promise.reject(new TypingsError(\n      `Unable to compile \"${name}\", the typings are meant to be installed as ` +\n      `global but attempted to be compiled as an external module`\n    ))\n  }\n\n  // Ensure the resolution is a valid target.\n  for (const resolution of resolutions) {\n    if (resolution !== 'main' && resolution !== 'browser') {\n      return Promise.reject(new TypingsError(\n        `Unable to resolve using \"${resolution}\" setting`\n      ))\n    }\n  }\n\n  return Promise.all(resolutions.map(resolution => {\n    const imported: ts.MapLike<boolean> = {}\n\n    return compileDependencyTree(tree, extend(options, {\n      resolution,\n      readFiles,\n      imported\n    }))\n  }))\n    .then((output) => {\n      const results: ResolutionResult = {}\n\n      for (let i = 0; i < output.length; i++) {\n        results[resolutions[i]] = output[i]\n      }\n\n      return {\n        cwd,\n        name,\n        tree,\n        global,\n        results\n      }\n    })\n}\n\n/**\n * Extends the default options with different compilation settings.\n */\ninterface CompileOptions extends Options {\n  resolution: string\n  readFiles: ts.MapLike<Promise<string>>\n  imported: ts.MapLike<boolean>\n  name: string\n  emitter: Emitter\n}\n\n/**\n * Resolve override paths.\n */\nfunction resolveFromOverride (src: string, to: string | boolean, tree: DependencyTree): string {\n  if (typeof to === 'string') {\n    if (isModuleName(to)) {\n      const [moduleName, modulePath] = getModuleNameParts(to, tree)\n\n      return modulePath ? normalizeToDefinition(to) : moduleName\n    }\n\n    return resolveFrom(src, normalizeToDefinition(to))\n  }\n\n  return to ? src : undefined\n}\n\n/**\n * Resolve module locations (appending `.d.ts` to paths).\n */\nfunction resolveFromWithModuleName (src: string, to: string, tree: DependencyTree): string {\n  if (isModuleName(to)) {\n    const [moduleName, modulePath] = getModuleNameParts(to, tree)\n\n    return modulePath ? toDefinition(to) : moduleName\n  }\n\n  return resolveFrom(src, toDefinition(to))\n}\n\n/**\n * Get stringify options for a dependency.\n */\nfunction getStringifyOptions (\n  tree: DependencyTree,\n  options: CompileOptions,\n  parent: StringifyOptions\n): StringifyOptions {\n  const overrides: Overrides = {}\n  const isTypings = typeof tree.typings === 'string'\n  const main = isTypings ? tree.typings : tree.main\n  const browser = isTypings ? tree.browserTypings : tree.browser\n\n  if (options.resolution === 'browser' && browser) {\n    if (typeof browser === 'string') {\n      const mainDefinition = resolveFrom(tree.src, normalizeToDefinition(main))\n      const browserDefinition = resolveFrom(tree.src, normalizeToDefinition(browser))\n\n      overrides[mainDefinition] = browserDefinition\n    } else {\n      for (const key of Object.keys(browser)) {\n        const from = resolveFromOverride(tree.src, key, tree) as string\n        const to = resolveFromOverride(tree.src, browser[key], tree)\n\n        overrides[from] = to\n      }\n    }\n  }\n\n  const referenced: ts.MapLike<boolean> = {}\n  const dependencies: ts.MapLike<StringifyOptions> = {}\n  const entry = main == null ? undefined : normalizeToDefinition(main)\n  const prefix = `${parent ? parent.prefix : ''}${DEPENDENCY_SEPARATOR}${options.name}`\n\n  return extend(options, {\n    tree,\n    entry,\n    prefix,\n    overrides,\n    referenced,\n    dependencies,\n    parent\n  })\n}\n\n/**\n * Compile a dependency tree to a single definition.\n */\nfunction compileDependencyTree (tree: DependencyTree, options: CompileOptions): Promise<string> {\n  const stringifyOptions = getStringifyOptions(tree, options, undefined)\n  const contents: Array<Promise<string>> = []\n\n  if (Array.isArray(tree.files)) {\n    for (const file of tree.files) {\n      contents.push(compileDependencyPath(file, stringifyOptions))\n    }\n  }\n\n  // Supports only having `files` specified.\n  if (stringifyOptions.entry || contents.length === 0) {\n    contents.push(compileDependencyPath(null, stringifyOptions))\n  }\n\n  return Promise.all(contents).then(out => out.join(EOL))\n}\n\n/**\n * Compile a dependency for a path, with pre-created stringify options.\n */\nfunction compileDependencyPath (\n  path: string,\n  options: StringifyOptions,\n  parentModule?: ModuleOptions\n): Promise<string> {\n  const { tree, entry } = options\n  const dependencyPath = resolveFrom(tree.src, path || entry || 'index.d.ts')\n\n  return stringifyDependencyPath(dependencyPath, path, options, parentModule)\n}\n\n/**\n * Stringify options extend the compiler options.\n */\ninterface StringifyOptions extends CompileOptions {\n  entry: string\n  prefix: string\n  overrides: Overrides\n  referenced: ts.MapLike<boolean>\n  dependencies: ts.MapLike<StringifyOptions>\n  tree: DependencyTree\n  parent: StringifyOptions\n}\n\n/**\n * Read a file with a backup cache object.\n */\nfunction cachedReadFileFrom (path: string, options: StringifyOptions) {\n  if (!has(options.readFiles, path)) {\n    options.readFiles[path] = readFileFrom(path)\n  }\n\n  return options.readFiles[path]\n}\n\n/**\n * Return cached stringify options from the current options object.\n */\nfunction cachedStringifyOptions (name: string, compileOptions: CompileOptions, options: StringifyOptions) {\n  const tree = getDependency(name, options)\n\n  if (!has(options.dependencies, name)) {\n    if (tree) {\n      options.dependencies[name] = getStringifyOptions(tree, compileOptions, options)\n    } else {\n      options.dependencies[name] = null\n    }\n  }\n\n  return options.dependencies[name]\n}\n\n/**\n * Get possible path and dependency overrides.\n */\nfunction getPath (path: string, options: StringifyOptions) {\n  if (has(options.overrides, path)) {\n    return options.overrides[path]\n  }\n\n  return path\n}\n\n/**\n * Get dependency from stringify options.\n */\nfunction getDependency (name: string, options: StringifyOptions): DependencyTree {\n  const { tree, overrides } = options\n\n  if (has(overrides, name)) {\n    if (overrides[name]) {\n      return tree.dependencies[overrides[name] as string]\n    }\n  } else if (has(tree.dependencies, name)) {\n    return tree.dependencies[name]\n  }\n}\n\n/**\n * Track options per-file.\n */\ninterface ModuleOptions {\n  path: string\n  rawPath: string\n  parent?: ModuleOptions\n  isExternal: boolean\n}\n\n/**\n * Stringify a dependency file.\n */\nfunction stringifyDependencyPath (\n  rawPath: string,\n  originalPath: string,\n  options: StringifyOptions,\n  moduleOptions: ModuleOptions\n): Promise<string> {\n  const path = getPath(rawPath, options)\n  const { tree, global, cwd, resolution, name, readFiles, imported, meta, emitter } = options\n  const importedPath = importPath(rawPath, pathFromDefinition(rawPath), options)\n\n  // Return `null` to skip the dependency writing, could have the same import twice.\n  if (has(imported, importedPath)) {\n    return Promise.resolve<string>(null)\n  }\n\n  // Set the file to \"already imported\" to avoid duplication.\n  imported[importedPath] = true\n\n  // Emit compile events for progression.\n  emitter.emit('compile', { name, rawPath, tree, resolution })\n\n  // Load a dependency path.\n  function loadByModuleName (path: string) {\n    const [moduleName, modulePath] = getModuleNameParts(path, tree)\n    const compileOptions = { cwd, resolution, readFiles, imported, emitter, name: moduleName, global: false, meta }\n    const stringifyOptions = cachedStringifyOptions(moduleName, compileOptions, options)\n\n    // When no options are returned, the dependency is missing.\n    if (!stringifyOptions) {\n      return Promise.resolve<string>(null)\n    }\n\n    return compileDependencyPath(modulePath, stringifyOptions, moduleOptions)\n  }\n\n  // Check if the path is resolving to a module name before reading.\n  if (isModuleName(path)) {\n    return loadByModuleName(path)\n  }\n\n  return cachedReadFileFrom(path, options)\n    .then(\n      function (rawContents) {\n        const info = ts.preProcessFile(rawContents)\n        const contents = rawContents.replace(REFERENCE_REGEXP, '')\n        const sourceFile = ts.createSourceFile(rawPath, contents, ts.ScriptTarget.Latest, true)\n        const importedFiles = info.importedFiles.map(x => resolveFromWithModuleName(path, x.fileName, tree))\n        const referencedFiles = info.referencedFiles.map(x => resolveFrom(path, x.fileName))\n\n        const childModuleOptions: ModuleOptions = {\n          path: path,\n          rawPath: rawPath,\n          parent: moduleOptions,\n          isExternal: (ts as any).isExternalModule(sourceFile)\n        }\n\n        // All dependencies MUST be imported for global modules.\n        if (global) {\n          Object.keys(tree.dependencies).forEach(x => importedFiles.push(x))\n        }\n\n        const imports = importedFiles.map(importedFile => {\n          const path = getPath(importedFile, options)\n\n          if (isModuleName(path)) {\n            return loadByModuleName(path)\n          }\n\n          return stringifyDependencyPath(path, importedFile, options, childModuleOptions)\n        })\n\n        return Promise.all(imports)\n          .then<string>(imports => {\n            const stringified = stringifySourceFile(sourceFile, originalPath, options, childModuleOptions)\n\n            for (const reference of referencedFiles) {\n              emitter.emit('reference', { name, rawPath, reference, tree, resolution })\n            }\n\n            const out = imports.filter(x => x != null)\n            out.push(stringified)\n            const contents = out.join(EOL)\n\n            emitter.emit('compiled', { name, rawPath, tree, resolution, contents })\n\n            return contents\n          })\n      },\n      function (cause) {\n        const authorPhrase = options.parent ? `The author of \"${options.parent.name}\" needs to` : 'You should'\n        const relativePath = relativeTo(tree.src, path)\n\n        // Provide better errors for the entry path.\n        if (originalPath == null) {\n          return Promise.reject(new TypingsError(\n            `Unable to read typings for \"${options.name}\". ` +\n            `${authorPhrase} check the entry paths in \"${basename(tree.src)}\" are up to date`,\n            cause\n          ))\n        }\n\n        return Promise.reject(new TypingsError(\n          `Unable to read \"${relativePath}\" from \"${options.name}\". ` +\n          `${authorPhrase} validate all import paths are accurate (case sensitive and relative)`,\n          cause\n        ))\n      }\n    )\n}\n\n/**\n * Separate the module name into pieces.\n */\nfunction getModuleNameParts (name: string, tree: DependencyTree): [string, string] {\n  const parts = name.split(/[\\\\\\/]/g)\n  let len = parts.length\n\n  while (len) {\n    len--\n\n    const name = parts.slice(0, len).join('/')\n    const path = parts.slice(len).join('/')\n\n    if (tree.dependencies[name]) {\n      return [name, path]\n    }\n  }\n\n  return [parts.join('/'), null]\n}\n\n/**\n * Normalize import paths against the prefix.\n */\nfunction importPath (path: string, name: string, options: StringifyOptions) {\n  const { prefix, tree } = options\n  const resolved = getPath(resolveFromWithModuleName(path, name, tree), options)\n\n  if (isModuleName(resolved)) {\n    const [moduleName, modulePath] = getModuleNameParts(resolved, tree)\n\n    // If the dependency is not available, *do not* transform - it's probably global.\n    if (tree.dependencies[moduleName] == null) {\n      return name\n    }\n\n    return `${prefix}${DEPENDENCY_SEPARATOR}${modulePath ? pathFromDefinition(resolved) : resolved}`\n  }\n\n  const relativePath = relativeTo(tree.src, pathFromDefinition(resolved))\n\n  return normalizeSlashes(join(prefix, relativePath))\n}\n\n/**\n * Stringify a dependency file contents.\n */\nfunction stringifySourceFile (\n  sourceFile: ts.SourceFile,\n  originalPath: string,\n  options: StringifyOptions,\n  moduleOptions: ModuleOptions\n) {\n  const { isExternal, path } = moduleOptions\n  const { tree, name, prefix, parent, cwd, global } = options\n  const parentModule = moduleOptions.parent\n\n  // Output information for the original type source.\n  const source = isHttp(path) ? path : normalizeSlashes(relative(cwd, path))\n  const meta = options.meta ? `// Generated by ${PROJECT_NAME}${EOL}// Source: ${source}${EOL}` : ''\n\n  if (global) {\n    if (isExternal) {\n      throw new TypingsError(\n        `Attempted to compile \"${name}\" as a global ` +\n        `module, but it looks like an external module. ` +\n        `You'll need to remove the global option to continue.`\n      )\n    }\n\n    return `${meta}${normalizeEOL(sourceFile.getText().trim(), EOL)}${EOL}`\n  } else {\n    if (!isExternal && !(parentModule && parentModule.isExternal)) {\n      throw new TypingsError(\n        `Attempted to compile \"${name}\" as an external module, ` +\n        `but it looks like a global module. ` +\n        `You'll need to enable the global option to continue.`\n      )\n    }\n  }\n\n  let hasExports = false\n  let hasDefaultExport = false\n  let hasExportEquals = false\n  let hasLocalImports = false\n  let wasDeclared = false\n\n  // Custom replacer function to rewrite the file.\n  function replacer (node: ts.Node) {\n    // Flag `export =` as the main re-definition needs to be written different.\n    if (node.kind === ts.SyntaxKind.ExportAssignment) {\n      hasDefaultExport = !(node as ts.ExportAssignment).isExportEquals\n      hasExportEquals = !hasDefaultExport\n    } else if (node.kind === ts.SyntaxKind.ExportDeclaration) {\n      hasExports = true\n    } else if (node.kind === ts.SyntaxKind.ExportSpecifier) {\n      hasDefaultExport = hasDefaultExport || (node as ts.ExportSpecifier).name.getText() === 'default'\n    }\n\n    hasExports = hasExports || !!(node.flags & ts.NodeFlags.Export)\n    hasDefaultExport = hasDefaultExport || !!(node.flags & ts.NodeFlags.Default)\n\n    if (\n      node.kind === ts.SyntaxKind.StringLiteral &&\n      (\n        node.parent.kind === ts.SyntaxKind.ExportDeclaration ||\n        node.parent.kind === ts.SyntaxKind.ImportDeclaration ||\n        node.parent.kind === ts.SyntaxKind.ModuleDeclaration\n      )\n    ) {\n      hasLocalImports = hasLocalImports || !isModuleName((node as ts.StringLiteral).text)\n\n      return ` '${importPath(path, (node as ts.StringLiteral).text, options)}'`\n    }\n\n    if (node.kind === ts.SyntaxKind.DeclareKeyword) {\n      // Notify the reader to remove leading trivia.\n      wasDeclared = true\n\n      return sourceFile.text.slice(node.getFullStart(), node.getStart())\n    }\n\n    if (node.kind === ts.SyntaxKind.ExternalModuleReference) {\n      const requirePath = importPath(path, (node as any).expression.text, options)\n\n      return ` require('${requirePath}')`\n    }\n  }\n\n  // Read through the file.\n  function read (start: number, end: number) {\n    const text = sourceFile.text.slice(start, end)\n\n    // Trim leading whitespace.\n    if (start === 0) {\n      return text.replace(/^\\s+$/, '')\n    }\n\n    // Trim trailing whitespace.\n    if (end == null) {\n      return text.replace(/\\s+$/, '')\n    }\n\n    // Remove leading whitespace from the statement after \"declare\".\n    if (wasDeclared) {\n      wasDeclared = false\n\n      return text.replace(/^\\s+/, '')\n    }\n\n    return text\n  }\n\n  // Create an alias/proxy module namespace to expose the implementation.\n  function alias (name: string) {\n    const imports: string[] = []\n\n    if (hasExportEquals) {\n      imports.push(`import main = require('${modulePath}');`)\n      imports.push(`export = main;`)\n    } else {\n      if (hasExports) {\n        imports.push(`export * from '${modulePath}';`)\n      }\n\n      if (hasDefaultExport) {\n        imports.push(`export { default } from '${modulePath}';`)\n      }\n    }\n\n    // No aliases, nothing exported.\n    if (imports.length === 0) {\n      return ''\n    }\n\n    return declareText(name, imports.join(EOL))\n  }\n\n  const isEntry = originalPath == null\n  const moduleText = normalizeEOL(processTree(sourceFile, replacer, read), EOL)\n  const moduleName = parent && parent.global ? name : prefix\n\n  // Direct usage of definition/typings. This is *not* a psuedo-module.\n  if (isEntry && !hasLocalImports) {\n    return meta + declareText(parent ? moduleName : name, moduleText)\n  }\n\n  const modulePath = importPath(path, pathFromDefinition(path), options)\n  const prettyPath = normalizeSlashes(join(name, relativeTo(tree.src, pathFromDefinition(path))))\n  const declared = declareText(modulePath, moduleText)\n\n  if (!isEntry) {\n    return meta + declared + (parent ? '' : alias(prettyPath))\n  }\n\n  return meta + declared + (parent ? '' : alias(prettyPath)) + alias(parent ? moduleName : name)\n}\n\n/**\n * Declare a module.\n */\nfunction declareText (name: string, text: string) {\n  return `declare module '${name}' {${text ? EOL + text + EOL : ''}}${EOL}`\n}\n\n/**\n * Rewrite TypeScript source files.\n *\n * Reference: https://github.com/SitePen/dts-generator/blob/22402351ffd953bf32344a0e48f2ba073fc5b65a/index.ts#L70-L101\n */\nfunction processTree (\n  sourceFile: ts.SourceFile,\n  replacer: (node: ts.Node) => string,\n  reader: (start: number, end?: number) => string\n): string {\n  let code = ''\n  let position = 0\n\n  function skip (node: ts.Node) {\n    position = node.end\n  }\n\n  function readThrough (node: ts.Node) {\n    if (node.pos > position) {\n      code += reader(position, node.pos)\n      position = node.pos\n    }\n  }\n\n  function visit (node: ts.Node) {\n    readThrough(node)\n\n    const replacement = replacer(node)\n\n    if (replacement != null) {\n      code += replacement\n      skip(node)\n    } else {\n      ts.forEachChild(node, visit)\n    }\n  }\n\n  visit(sourceFile)\n\n  code += reader(position)\n\n  return code\n}\n"]}